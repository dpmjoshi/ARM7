ARM COMPILER V2.50a,  uart                                                                 23/05/13  14:55:53  PAGE 1   


ARM COMPILER V2.50a, COMPILATION OF MODULE uart
OBJECT MODULE PLACED IN uart.OBJ
COMPILER INVOKED BY: C:\Keil\ARM\BIN\CA.exe uart.c THUMB BROWSE DEBUG TABS(4) 

stmt  level    source

    1          /*
    2          * functions :-
    3          * 1) void uart0_init(void)
    4          *    Baud rate :- 9600
    5          *    
    6          */
    7          
    8          #include "includes.h"
    9          
   10          //#include "includes.h"
   11          
   12          
   13          
   14          
   15          void uart_init(void);
   16          void uart_init_interrupt(void);
   17          U8 uart0_rx_byte(void);
   18          U8 uart1_rx_byte(void);
   19          void uart0_tx_byte(U8 );
   20          void uart1_tx_byte(U8 );
   21          void uart0_rx_string(U8*);
   22          void uart1_rx_string(U8*);
   23          void uart0_tx_string(U8*);
   24          void uart1_tx_string(U8*);
   25          void uart0_isr(void) __irq ;
   26          void uart1_isr(void) __irq ;
   27          
   28          U8 rx_data;
   29          U8 Uc_user_option;
   30          U8 uc_u1rbr = 0;
   31          
   32          U8 Uc_eof_zb = 0;
   33          U8 Uc_uart0_str_zb[100];
   34          U8 Uc_byte_cnt_zb = 0;
   35          
   36          U8 Uc_eof_gsm = 0;
   37          U8 Uc_uart1_str_gsm[200];
   38          U8 Uc_byte_cnt_gsm = 0;
   39          U8 Uc_stat_code_gsm = 0;
   40          
   41          
   42          
   43          void uart_init(void)                //Baud Rate: 9600 bps without interrupt
   44          {
   45   1          PINSEL0 |=  0x00050005;
   46   1          U0LCR    =  DLAB_EN;
   47   1          U0DLL    =  BR9600_LSB;
   48   1          U0DLM    =  BR9600_MSB;
   49   1          U0LCR    =  DLAB_DISABLE_8BIT_WRDLEN;
   50   1          
   51   1      
   52   1          U1LCR    =  DLAB_EN;
   53   1          U1DLL    =  BR9600_LSB;
   54   1          U1DLM    =  BR9600_MSB;
   55   1          U1LCR    =  DLAB_DISABLE_8BIT_WRDLEN;
   56   1      
   57   1      }
   58          
   59          void uart_init_interrupt(void)      //Baud Rate: 9600 bps with interrupt
ARM COMPILER V2.50a,  uart                                                                 23/05/13  14:55:53  PAGE 2   

   60          {
   61   1          PINSEL0 |=  0x00050005;
   62   1          U0LCR    =  DLAB_EN;
   63   1          U0DLL    =  BR9600_LSB;
   64   1          U0DLM    =  BR9600_MSB;
   65   1          U0LCR    =  DLAB_DISABLE_8BIT_WRDLEN;
   66   1          
   67   1           
   68   1          U1LCR    =  DLAB_EN;
   69   1          U1DLL    =  BR9600_LSB;
   70   1          U1DLM    =  BR9600_MSB;
   71   1          U1LCR    =  DLAB_DISABLE_8BIT_WRDLEN;
   72   1          
   73   1        
   74   1          VICIntSelect  =  0x00;    
   75   1          VICVectAddr0  =  (unsigned) uart0_isr ; 
   76   1          VICVectCntl0  =  ENABLE_SLOT | UART0_CHANNEL_NO;
   77   1          VICIntEnable  |= (1 << UART0_CHANNEL_NO);
   78   1          U0IER         =  0x01;
   79   1           
   80   1          VICIntSelect  =  0x00;    
   81   1          VICVectAddr1  =  (unsigned) uart1_isr ; 
   82   1          VICVectCntl1  =  ENABLE_SLOT | UART1_CHANNEL_NO;
   83   1          VICIntEnable  |= (1 << UART1_CHANNEL_NO);
   84   1          U1IER         =  0x01;  
   85   1      
   86   1          uart0_tx_string("\n\rUART0 connnected @9600");
   87   1      
   88   1      }
   89          
   90          U8 uart0_rx_byte(void)                             // Receive single byte
   91          {
   92   1          U8 rx_data;
   93   1          while(!(U0LSR&0X01));
   94   1          rx_data = U0RBR;
   95   1          return(rx_data);
   96   1      }
   97          
   98          U8 uart1_rx_byte(void)                             // Receive single byte
   99          {
  100   1          U8 rx_data;
  101   1          while(!(U1LSR&0X01));
  102   1          rx_data = U1RBR;
  103   1          return(rx_data);
  104   1      }
  105          
  106          void uart0_tx_byte(U8 tx_data)                     // Transmit single byte
  107          {
  108   1          U0THR = tx_data;
  109   1          while(!(U0LSR&0X20));
  110   1      }
  111          
  112          void uart1_tx_byte(U8 tx_data)                     // Transmit single byte
  113          {
  114   1          U1THR = tx_data;
  115   1          while(!(U1LSR&0X20));
  116   1      }
  117          
  118          void uart0_rx_string(U8* pdata)                  // Receive string
  119          {
  120   1      
  121   1          U8 len=0;
  122   1          do
  123   1          {
  124   2              pdata[len]=uart0_rx_byte(); 
  125   2          }
ARM COMPILER V2.50a,  uart                                                                 23/05/13  14:55:53  PAGE 3   

  126   1          while (pdata[len++]!=0x0d);
  127   1          pdata[len]='\0';
  128   1      
  129   1      }
  130          
  131          void uart1_rx_string(U8* pdata)                  // Receive string
  132          {
  133   1      
  134   1          U8 len=0;
  135   1          do
  136   1          {
  137   2              pdata[len]=uart1_rx_byte(); 
  138   2          }
  139   1          while (pdata[len++]!=0x0d);
  140   1          pdata[len]='\0';
  141   1      
  142   1      }
  143          
  144          
  145          void uart0_tx_string(U8* tx_data)                // Transmit string
  146          {
  147   1          /*
  148   1          uart0_tx_byte(0x0d);
  149   1          uart0_tx_byte(0x0a);
  150   1          */
  151   1          while(*tx_data != '\0')
  152   1          {
  153   2              uart0_tx_byte(*tx_data);
  154   2              tx_data++;
  155   2          }     
  156   1      }
  157          
  158          void uart1_tx_string(U8* tx_data)                // Transmit string
  159          {
  160   1          /*
  161   1          uart1_tx_byte(0x0d);
  162   1          uart1_tx_byte(0x0a);
  163   1          */
  164   1          while(*tx_data != '\0')
  165   1          {
  166   2              uart1_tx_byte(*tx_data);
  167   2              tx_data++;
  168   2          }     
  169   1      }
  170          
  171          
  172          void uart0_isr(void) __irq
  173          {
  174   1          //Uc_eof_zb = 0;
  175   1          Uc_uart0_str_zb[Uc_byte_cnt_zb] = U0RBR; 
  176   1        //    uart0_tx_byte(Uc_uart0_str_zb[Uc_byte_cnt_zb]);
  177   1          if((Uc_uart0_str_zb[Uc_byte_cnt_zb] == '\r'))
  178   1          {
  179   2              if(Uc_byte_cnt_zb > 76)
  180   2              {
  181   3                  uart0_tx_string("\n\n\r Buffer limit exceeded!!!");
  182   3                  uart0_tx_string("\n\r Please enter messege within limits(max 77 characters)");
  183   3              }
  184   2              else
  185   2              {
  186   3                  Uc_uart0_str_zb[Uc_byte_cnt_zb] = '\0';
  187   3                  Uc_eof_zb = 1;
  188   3              }
  189   2                  Uc_byte_cnt_zb = 0;
  190   2          }
  191   1          if((Uc_eof_zb == 0) && (Uc_byte_cnt_zb < 77))
ARM COMPILER V2.50a,  uart                                                                 23/05/13  14:55:53  PAGE 4   

  192   1          {
  193   2              Uc_byte_cnt_zb++;
  194   2          }   
  195   1          VICVectAddr = 0;
  196   1      
  197   1      }
  198          
  199          
  200          void uart1_isr(void) __irq
  201          {   
  202   1          uc_u1rbr = U1RBR;
  203   1      /*  if(uc_u1rbr == '\n')
  204   1          {
  205   1          uc_u1rbr = '@';
  206   1          }
  207   1          else if(uc_u1rbr == '\r')
  208   1          {
  209   1          uc_u1rbr = '#';
  210   1          }
  211   1      */  
  212   1          uart0_tx_byte(uc_u1rbr);             
  213   1          
  214   1          switch(Uc_stat_code_gsm)
  215   1          {
  216   2            case  0:  if(uc_u1rbr == '\r')
  217   2                      {
  218   3                          Uc_stat_code_gsm = 10;
  219   3                          Uc_byte_cnt_gsm = 0;
  220   3                          Uc_uart1_str_gsm[Uc_byte_cnt_gsm] = uc_u1rbr;   
  221   3                          Uc_byte_cnt_gsm++;
  222   3                      }
  223   2                      break;
  224   2      
  225   2            case 10:  Uc_uart1_str_gsm[Uc_byte_cnt_gsm] = uc_u1rbr;    // Status code 10 signifies that first '\r' h
             -as been received and coming bytes  7
  226   2                      Uc_byte_cnt_gsm++;                           // will be a part of GSM response. This response is further analyzed in cas
             -e 11.
  227   2                      if(uc_u1rbr == '\r')
  228   2                      {
  229   3                          Uc_stat_code_gsm = 11;
  230   3                      }
  231   2                      break;
  232   2      
  233   2            case 11:  Uc_uart1_str_gsm[Uc_byte_cnt_gsm] = uc_u1rbr;
  234   2                      Uc_uart1_str_gsm[Uc_byte_cnt_gsm + 1] = '\0';
  235   2                      
  236   2                      break;
  237   2                                
  238   2            case 20:  if(uc_u1rbr == '+')
  239   2                      {               
  240   3                          Uc_byte_cnt_gsm = 0;    
  241   3                          SMS_cur.detail[Uc_byte_cnt_gsm] = uc_u1rbr;
  242   3                          Uc_byte_cnt_gsm++;
  243   3                          Uc_stat_code_gsm = 21;
  244   3                      }
  245   2                      break;
  246   2      
  247   2            case 21:  SMS_cur.detail[Uc_byte_cnt_gsm] = uc_u1rbr;
  248   2                      Uc_byte_cnt_gsm++;                           
  249   2                      if(uc_u1rbr == '\n')
  250   2                      {
  251   3                          Uc_stat_code_gsm = 22;
  252   3                      }
  253   2                      break;
  254   2      
  255   2            case 22:  SMS_cur.detail[Uc_byte_cnt_gsm] = uc_u1rbr;
ARM COMPILER V2.50a,  uart                                                                 23/05/13  14:55:53  PAGE 5   

  256   2                      Uc_byte_cnt_gsm++;                           
  257   2                      if(uc_u1rbr == '\n')
  258   2                      {
  259   3                          SMS_cur.detail[Uc_byte_cnt_gsm] = '\0';
  260   3                          Uc_stat_code_gsm = 23;
  261   3                          Uc_byte_cnt_gsm = 0;
  262   3                      }
  263   2                      break;
  264   2      
  265   2            case 23:  SMS_cur.data[Uc_byte_cnt_gsm] = uc_u1rbr;
  266   2                      Uc_byte_cnt_gsm++;                           
  267   2                      if(uc_u1rbr == '\n')
  268   2                      {
  269   3                          SMS_cur.data[Uc_byte_cnt_gsm] = '\0';
  270   3                          Uc_stat_code_gsm = 24;
  271   3                      }
  272   2          }
  273   1          
  274   1          VICVectAddr = 0;
  275   1      
  276   1      }
ARM COMPILER V2.50a,  uart                                                                 23/05/13  14:55:53  PAGE 6   

ASSEMBLY LISTING OF GENERATED OBJECT CODE



*** EXTERNALS:
 EXTERN DATA (SMS_cur)



*** PUBLICS:
 PUBLIC         uart_init?T
 PUBLIC         uart0_rx_byte?T
 PUBLIC         uart1_rx_byte?T
 PUBLIC         uart0_tx_byte?T
 PUBLIC         uart0_tx_byte?A
 PUBLIC         uart1_tx_byte?T
 PUBLIC         uart0_rx_string?T
 PUBLIC         uart1_rx_string?T
 PUBLIC         uart0_tx_string?T
 PUBLIC         uart0_tx_string?A
 PUBLIC         uart1_tx_string?T
 PUBLIC         uart_init_interrupt?T
 PUBLIC         uart0_isr?A
 PUBLIC         uart1_isr?A
 PUBLIC         Uc_user_option
 PUBLIC         Uc_uart0_str_zb
 PUBLIC         Uc_eof_zb
 PUBLIC         Uc_eof_gsm
 PUBLIC         Uc_uart1_str_gsm
 PUBLIC         Uc_stat_code_gsm
 PUBLIC         Uc_byte_cnt_gsm
 PUBLIC         rx_data
 PUBLIC         uc_u1rbr
 PUBLIC         Uc_byte_cnt_zb



*** DATA SEGMENT '?CON?uart':
 00000000          ??S_3:
 00000000            DB          0x0A,0x0D,' Please enter messege within'
 0000001E            DB          ' limits(max 77 characters)',0x00
 00000039          ??S_2:
 00000039            DB          0x0A,0x0A,0x0D,' Buffer limit exceeded!'
 00000053            DB          '!!',0x00
 00000056          ??S_1:
 00000056            DB          0x0A,0x0D,'UART0 connnected @9600',0x00

*** DATA SEGMENT '?DT0?uart':
 00000000          Uc_user_option:
 00000000            DS          1
 00000001          Uc_uart0_str_zb:
 00000001            DS          100
 00000065          Uc_eof_zb:
 00000065           BEGIN_INIT
 00000065  00        DB          0x0
 00000066           END_INIT
 00000066          Uc_eof_gsm:
 00000066           BEGIN_INIT
 00000066  00        DB          0x0
 00000067           END_INIT
 00000067          Uc_uart1_str_gsm:
 00000067            DS          200
 0000012F          Uc_stat_code_gsm:
 0000012F           BEGIN_INIT
 0000012F  00        DB          0x0
 00000130           END_INIT
 00000130          Uc_byte_cnt_gsm:
 00000130           BEGIN_INIT
 00000130  00        DB          0x0
 00000131           END_INIT
 00000131          rx_data:
 00000131            DS          1
ARM COMPILER V2.50a,  uart                                                                 23/05/13  14:55:53  PAGE 7   

 00000132          uc_u1rbr:
 00000132           BEGIN_INIT
 00000132  00        DB          0x0
 00000133           END_INIT
 00000133          Uc_byte_cnt_zb:
 00000133           BEGIN_INIT
 00000133  00        DB          0x0
 00000134           END_INIT



*** CODE SEGMENT '?PR?uart_init?T?uart':
   43: void uart_init(void)                //Baud Rate: 9600 bps without interrupt
 00000000  B410      PUSH        {R4}
   45:     PINSEL0 |=  0x00050005;
 00000002  4800      LDR         R2,=0x50005
 00000004  4800      LDR         R0,=0xE002C000
 00000006  6801      LDR         R1,[R0,#0x0]
 00000008  4311      ORR         R1,R2
 0000000A  6001      STR         R1,[R0,#0x0]
   46:     U0LCR    =  DLAB_EN;
 0000000C  2480      MOV         R4,#0x80
 0000000E  4800      LDR         R0,=0xE000C00C
 00000010  7004      STRB        R4,[R0,#0x0]
   47:     U0DLL    =  BR9600_LSB;
 00000012  2361      MOV         R3,#0x61
 00000014  4800      LDR         R0,=0xE000C000
 00000016  7003      STRB        R3,[R0,#0x0]
   48:     U0DLM    =  BR9600_MSB;
 00000018  2200      MOV         R2,#0x0
 0000001A  4800      LDR         R0,=0xE000C004
 0000001C  7002      STRB        R2,[R0,#0x0]
   49:     U0LCR    =  DLAB_DISABLE_8BIT_WRDLEN;
 0000001E  2103      MOV         R1,#0x3
 00000020  4800      LDR         R0,=0xE000C00C
 00000022  7001      STRB        R1,[R0,#0x0]
   52:     U1LCR    =  DLAB_EN;
 00000024  4800      LDR         R0,=0xE001000C
 00000026  7004      STRB        R4,[R0,#0x0]
   53:     U1DLL    =  BR9600_LSB;
 00000028  4800      LDR         R0,=0xE0010000
 0000002A  7003      STRB        R3,[R0,#0x0]
   54:     U1DLM    =  BR9600_MSB;
 0000002C  4800      LDR         R0,=0xE0010004
 0000002E  7002      STRB        R2,[R0,#0x0]
   55:     U1LCR    =  DLAB_DISABLE_8BIT_WRDLEN;
 00000030  4800      LDR         R0,=0xE001000C
 00000032  7001      STRB        R1,[R0,#0x0]
   57: }
 00000034  BC10      POP         {R4}
 00000036  4770      BX          R14
 00000038          ENDP ; 'uart_init?T'


*** CODE SEGMENT '?PR?uart_init_interrupt?T?uart':
   59: void uart_init_interrupt(void)      //Baud Rate: 9600 bps with interrupt
 00000000  B510      PUSH        {R4,LR}
   61:     PINSEL0 |=  0x00050005;
 00000002  4800      LDR         R2,=0x50005
 00000004  4800      LDR         R0,=0xE002C000
 00000006  6801      LDR         R1,[R0,#0x0]
 00000008  4311      ORR         R1,R2
 0000000A  6001      STR         R1,[R0,#0x0]
   62:     U0LCR    =  DLAB_EN;
 0000000C  2480      MOV         R4,#0x80
 0000000E  4800      LDR         R0,=0xE000C00C
 00000010  7004      STRB        R4,[R0,#0x0]
   63:     U0DLL    =  BR9600_LSB;
 00000012  2361      MOV         R3,#0x61
 00000014  4800      LDR         R0,=0xE000C000
ARM COMPILER V2.50a,  uart                                                                 23/05/13  14:55:53  PAGE 8   

 00000016  7003      STRB        R3,[R0,#0x0]
   64:     U0DLM    =  BR9600_MSB;
 00000018  2200      MOV         R2,#0x0
 0000001A  4800      LDR         R0,=0xE000C004
 0000001C  7002      STRB        R2,[R0,#0x0]
   65:     U0LCR    =  DLAB_DISABLE_8BIT_WRDLEN;
 0000001E  2103      MOV         R1,#0x3
 00000020  4800      LDR         R0,=0xE000C00C
 00000022  7001      STRB        R1,[R0,#0x0]
   68:     U1LCR    =  DLAB_EN;
 00000024  4800      LDR         R0,=0xE001000C
 00000026  7004      STRB        R4,[R0,#0x0]
   69:     U1DLL    =  BR9600_LSB;
 00000028  4800      LDR         R0,=0xE0010000
 0000002A  7003      STRB        R3,[R0,#0x0]
   70:     U1DLM    =  BR9600_MSB;
 0000002C  4800      LDR         R0,=0xE0010004
 0000002E  7002      STRB        R2,[R0,#0x0]
   71:     U1LCR    =  DLAB_DISABLE_8BIT_WRDLEN;
 00000030  4800      LDR         R0,=0xE001000C
 00000032  7001      STRB        R1,[R0,#0x0]
   74:     VICIntSelect  =  0x00;    
 00000034  2200      MOV         R2,#0x0
 00000036  4800      LDR         R0,=0xFFFFF00C
 00000038  6002      STR         R2,[R0,#0x0]
   75:     VICVectAddr0  =  (unsigned) uart0_isr ; 
 0000003A  4900      LDR         R1,=uart0_isr?A ; uart0_isr?A
 0000003C  4800      LDR         R0,=0xFFFFF100
 0000003E  6001      STR         R1,[R0,#0x0]
   76:     VICVectCntl0  =  ENABLE_SLOT | UART0_CHANNEL_NO;
 00000040  2126      MOV         R1,#0x26
 00000042  4800      LDR         R0,=0xFFFFF200
 00000044  6001      STR         R1,[R0,#0x0]
   77:     VICIntEnable  |= (1 << UART0_CHANNEL_NO);
 00000046  2340      MOV         R3,#0x40
 00000048  4800      LDR         R0,=0xFFFFF010
 0000004A  6801      LDR         R1,[R0,#0x0]
 0000004C  4319      ORR         R1,R3
 0000004E  6001      STR         R1,[R0,#0x0]
   78:     U0IER         =  0x01;
 00000050  2101      MOV         R1,#0x1
 00000052  4800      LDR         R0,=0xE000C004
 00000054  7001      STRB        R1,[R0,#0x0]
   80:     VICIntSelect  =  0x00;    
 00000056  4800      LDR         R0,=0xFFFFF00C
 00000058  6002      STR         R2,[R0,#0x0]
   81:     VICVectAddr1  =  (unsigned) uart1_isr ; 
 0000005A  4A00      LDR         R2,=uart1_isr?A ; uart1_isr?A
 0000005C  4800      LDR         R0,=0xFFFFF104
 0000005E  6002      STR         R2,[R0,#0x0]
   82:     VICVectCntl1  =  ENABLE_SLOT | UART1_CHANNEL_NO;
 00000060  2227      MOV         R2,#0x27
 00000062  4800      LDR         R0,=0xFFFFF204
 00000064  6002      STR         R2,[R0,#0x0]
   83:     VICIntEnable  |= (1 << UART1_CHANNEL_NO);
 00000066  2380      MOV         R3,#0x80
 00000068  4800      LDR         R0,=0xFFFFF010
 0000006A  6802      LDR         R2,[R0,#0x0]
 0000006C  431A      ORR         R2,R3
 0000006E  6002      STR         R2,[R0,#0x0]
   84:     U1IER         =  0x01;  
 00000070  4800      LDR         R0,=0xE0010004
 00000072  7001      STRB        R1,[R0,#0x0]
   86:     uart0_tx_string("\n\rUART0 connnected @9600");
 00000074  4800      LDR         R0,=??S_1 ; ??S_1
 00000076  F7FF      BL          uart0_tx_string?T  ; T=0x0001  (1)
ARM COMPILER V2.50a,  uart                                                                 23/05/13  14:55:53  PAGE 9   

 00000078  FFC3      BL          uart0_tx_string?T  ; T=0x0001  (2)
   88: }
 0000007A  BC10      POP         {R4}
 0000007C  BC08      POP         {R3}
 0000007E  4718      BX          R3
 00000080          ENDP ; 'uart_init_interrupt?T'


*** CODE SEGMENT '?PR?uart0_rx_byte?T?uart':
   91: {
 00000000            ; SCOPE-START
   93:     while(!(U0LSR&0X01));
 00000000          L_1:
 00000000  4800      LDR         R0,=0xE000C014
 00000002  7800      LDRB        R0,[R0,#0x0]
 00000004  2101      MOV         R1,#0x1
 00000006  4208      TST         R0,R1
 00000008  D0FA      BEQ         L_1  ; T=0x00000000
   94:     rx_data = U0RBR;
 0000000A  4800      LDR         R0,=0xE000C000
 0000000C  7801      LDRB        R1,[R0,#0x0]
 0000000E  ---- Variable 'rx_data' assigned to Register 'R1' ----
   95:     return(rx_data);
 0000000E  1C08      MOV         R0,R1 ; rx_data
 00000010  0600      LSL         R0,R0,#0x18 ; rx_data
 00000012  0E00      LSR         R0,R0,#0x18
 00000014            ; SCOPE-END
   96: }
 00000014  4770      BX          R14
 00000016          ENDP ; 'uart0_rx_byte?T'


*** CODE SEGMENT '?PR?uart1_rx_byte?T?uart':
   99: {
 00000000            ; SCOPE-START
  101:     while(!(U1LSR&0X01));
 00000000          L_6:
 00000000  4800      LDR         R0,=0xE0010014
 00000002  7800      LDRB        R0,[R0,#0x0]
 00000004  2101      MOV         R1,#0x1
 00000006  4208      TST         R0,R1
 00000008  D0FA      BEQ         L_6  ; T=0x00000000
  102:     rx_data = U1RBR;
 0000000A  4800      LDR         R0,=0xE0010000
 0000000C  7801      LDRB        R1,[R0,#0x0]
 0000000E  ---- Variable 'rx_data' assigned to Register 'R1' ----
  103:     return(rx_data);
 0000000E  1C08      MOV         R0,R1 ; rx_data
 00000010  0600      LSL         R0,R0,#0x18 ; rx_data
 00000012  0E00      LSR         R0,R0,#0x18
 00000014            ; SCOPE-END
  104: }
 00000014  4770      BX          R14
 00000016          ENDP ; 'uart1_rx_byte?T'


*** CODE SEGMENT '?PR?uart0_tx_byte?T?uart':
  106: void uart0_tx_byte(U8 tx_data)                     // Transmit single byte
 00000000  1C02      MOV         R2,R0 ; tx_data
 00000002  ---- Variable 'tx_data' assigned to Register 'R2' ----
  108:     U0THR = tx_data;
 00000002  1C11      MOV         R1,R2 ; tx_data
 00000004  4800      LDR         R0,=0xE000C000
 00000006  7001      STRB        R1,[R0,#0x0]
  109:     while(!(U0LSR&0X20));
 00000008          L_11:
 00000008  4800      LDR         R0,=0xE000C014
 0000000A  7800      LDRB        R0,[R0,#0x0]
 0000000C  2120      MOV         R1,#0x20
 0000000E  4208      TST         R0,R1
 00000010  D0FA      BEQ         L_11  ; T=0x00000008
  110: }
ARM COMPILER V2.50a,  uart                                                                 23/05/13  14:55:53  PAGE 10  

 00000012  4770      BX          R14
 00000014          ENDP ; 'uart0_tx_byte?T'


*** CODE SEGMENT '?PR?uart1_tx_byte?T?uart':
  112: void uart1_tx_byte(U8 tx_data)                     // Transmit single byte
 00000000  1C02      MOV         R2,R0 ; tx_data
 00000002  ---- Variable 'tx_data' assigned to Register 'R2' ----
  114:     U1THR = tx_data;
 00000002  1C11      MOV         R1,R2 ; tx_data
 00000004  4800      LDR         R0,=0xE0010000
 00000006  7001      STRB        R1,[R0,#0x0]
  115:     while(!(U1LSR&0X20));
 00000008          L_15:
 00000008  4800      LDR         R0,=0xE0010014
 0000000A  7800      LDRB        R0,[R0,#0x0]
 0000000C  2120      MOV         R1,#0x20
 0000000E  4208      TST         R0,R1
 00000010  D0FA      BEQ         L_15  ; T=0x00000008
  116: }
 00000012  4770      BX          R14
 00000014          ENDP ; 'uart1_tx_byte?T'


*** CODE SEGMENT '?PR?uart0_rx_string?T?uart':
  118: void uart0_rx_string(U8* pdata)                  // Receive string
 00000000  B510      PUSH        {R4,LR}
 00000002  1C03      MOV         R3,R0 ; pdata
 00000004  ---- Variable 'pdata' assigned to Register 'R3' ----
  119: {
 00000004            ; SCOPE-START
  121:     U8 len=0;
 00000004  2200      MOV         R2,#0x0
 00000006  ---- Variable 'len' assigned to Register 'R2' ----
  122:     do
 00000006          L_19:
  124:         pdata[len]=uart0_rx_byte(); 
 00000006  F7FF      BL          uart0_rx_byte?T  ; T=0x0001  (1)
 00000008  FFFB      BL          uart0_rx_byte?T  ; T=0x0001  (2)
 0000000A  1C11      MOV         R1,R2 ; len
 0000000C  060C      LSL         R4,R1,#0x18 ; len
 0000000E  0E24      LSR         R4,R4,#0x18
 00000010  1C19      MOV         R1,R3 ; pdata
 00000012  5508      STRB        R0,[R1,R4]
  125:     }
 00000014  1C10      MOV         R0,R2 ; len
 00000016  3201      ADD         R2,#0x1
 00000018  0612      LSL         R2,R2,#0x18
 0000001A  0E12      LSR         R2,R2,#0x18
 0000001C  0601      LSL         R1,R0,#0x18 ; len
 0000001E  0E09      LSR         R1,R1,#0x18
 00000020  1C18      MOV         R0,R3 ; pdata
 00000022  5C40      LDRB        R0,[R0,R1]
 00000024  280D      CMP         R0,#0xD
 00000026  D1EE      BNE         L_19  ; T=0x00000006
  127:     pdata[len]='\0';
 00000028  2100      MOV         R1,#0x0
 0000002A  1C10      MOV         R0,R2 ; len
 0000002C  0602      LSL         R2,R0,#0x18 ; len
 0000002E  0E12      LSR         R2,R2,#0x18
 00000030  1C18      MOV         R0,R3 ; pdata
 00000032  5481      STRB        R1,[R0,R2]
 00000034            ; SCOPE-END
  129: }
 00000034  BC10      POP         {R4}
 00000036  BC08      POP         {R3}
 00000038  4718      BX          R3
 0000003A          ENDP ; 'uart0_rx_string?T'


*** CODE SEGMENT '?PR?uart1_rx_string?T?uart':
  131: void uart1_rx_string(U8* pdata)                  // Receive string
ARM COMPILER V2.50a,  uart                                                                 23/05/13  14:55:53  PAGE 11  

 00000000  B510      PUSH        {R4,LR}
 00000002  1C03      MOV         R3,R0 ; pdata
 00000004  ---- Variable 'pdata' assigned to Register 'R3' ----
  132: {
 00000004            ; SCOPE-START
  134:     U8 len=0;
 00000004  2200      MOV         R2,#0x0
 00000006  ---- Variable 'len' assigned to Register 'R2' ----
  135:     do
 00000006          L_23:
  137:         pdata[len]=uart1_rx_byte(); 
 00000006  F7FF      BL          uart1_rx_byte?T  ; T=0x0001  (1)
 00000008  FFFB      BL          uart1_rx_byte?T  ; T=0x0001  (2)
 0000000A  1C11      MOV         R1,R2 ; len
 0000000C  060C      LSL         R4,R1,#0x18 ; len
 0000000E  0E24      LSR         R4,R4,#0x18
 00000010  1C19      MOV         R1,R3 ; pdata
 00000012  5508      STRB        R0,[R1,R4]
  138:     }
 00000014  1C10      MOV         R0,R2 ; len
 00000016  3201      ADD         R2,#0x1
 00000018  0612      LSL         R2,R2,#0x18
 0000001A  0E12      LSR         R2,R2,#0x18
 0000001C  0601      LSL         R1,R0,#0x18 ; len
 0000001E  0E09      LSR         R1,R1,#0x18
 00000020  1C18      MOV         R0,R3 ; pdata
 00000022  5C40      LDRB        R0,[R0,R1]
 00000024  280D      CMP         R0,#0xD
 00000026  D1EE      BNE         L_23  ; T=0x00000006
  140:     pdata[len]='\0';
 00000028  2100      MOV         R1,#0x0
 0000002A  1C10      MOV         R0,R2 ; len
 0000002C  0602      LSL         R2,R0,#0x18 ; len
 0000002E  0E12      LSR         R2,R2,#0x18
 00000030  1C18      MOV         R0,R3 ; pdata
 00000032  5481      STRB        R1,[R0,R2]
 00000034            ; SCOPE-END
  142: }
 00000034  BC10      POP         {R4}
 00000036  BC08      POP         {R3}
 00000038  4718      BX          R3
 0000003A          ENDP ; 'uart1_rx_string?T'


*** CODE SEGMENT '?PR?uart0_tx_string?T?uart':
  145: void uart0_tx_string(U8* tx_data)                // Transmit string
 00000000  B500      PUSH        {LR}
 00000002  1C03      MOV         R3,R0 ; tx_data
 00000004  ---- Variable 'tx_data' assigned to Register 'R3' ----
  151:     while(*tx_data != '\0')
 00000004  E004      B           L_27  ; T=0x00000010
 00000006          L_29:
  153:         uart0_tx_byte(*tx_data);
 00000006  1C18      MOV         R0,R3 ; tx_data
 00000008  7800      LDRB        R0,[R0,#0x0] ; tx_data
 0000000A  F7FF      BL          uart0_tx_byte?T  ; T=0x0001  (1)
 0000000C  FFF9      BL          uart0_tx_byte?T  ; T=0x0001  (2)
  154:         tx_data++;
 0000000E  3301      ADD         R3,#0x1
  155:     }      
 00000010          L_27:
 00000010  1C18      MOV         R0,R3 ; tx_data
 00000012  7800      LDRB        R0,[R0,#0x0] ; tx_data
 00000014  2800      CMP         R0,#0x0
 00000016  D1F6      BNE         L_29  ; T=0x00000006
  156: }
 00000018  BC08      POP         {R3}
 0000001A  4718      BX          R3
ARM COMPILER V2.50a,  uart                                                                 23/05/13  14:55:53  PAGE 12  

 0000001C          ENDP ; 'uart0_tx_string?T'


*** CODE SEGMENT '?PR?uart1_tx_string?T?uart':
  158: void uart1_tx_string(U8* tx_data)                // Transmit string
 00000000  B500      PUSH        {LR}
 00000002  1C03      MOV         R3,R0 ; tx_data
 00000004  ---- Variable 'tx_data' assigned to Register 'R3' ----
  164:     while(*tx_data != '\0')
 00000004  E004      B           L_31  ; T=0x00000010
 00000006          L_33:
  166:         uart1_tx_byte(*tx_data);
 00000006  1C18      MOV         R0,R3 ; tx_data
 00000008  7800      LDRB        R0,[R0,#0x0] ; tx_data
 0000000A  F7FF      BL          uart1_tx_byte?T  ; T=0x0001  (1)
 0000000C  FFF9      BL          uart1_tx_byte?T  ; T=0x0001  (2)
  167:         tx_data++;
 0000000E  3301      ADD         R3,#0x1
  168:     }      
 00000010          L_31:
 00000010  1C18      MOV         R0,R3 ; tx_data
 00000012  7800      LDRB        R0,[R0,#0x0] ; tx_data
 00000014  2800      CMP         R0,#0x0
 00000016  D1F6      BNE         L_33  ; T=0x00000006
  169: }
 00000018  BC08      POP         {R3}
 0000001A  4718      BX          R3
 0000001C          ENDP ; 'uart1_tx_string?T'


*** CODE SEGMENT '?PR?uart0_isr?A?uart':
  172: void uart0_isr(void) __irq
 00000000  E92D501F  STMDB       R13!,{R0-R4,R12,LR}
  175:       Uc_uart0_str_zb[Uc_byte_cnt_zb] = U0RBR; 
 00000004  E5100000  LDR         R0,=0xE000C000
 00000008  E5D00000  LDRB        R0,[R0,#0x0]
 0000000C  E5101000  LDR         R1,=Uc_byte_cnt_zb ; Uc_byte_cnt_zb
 00000010  E5D11000  LDRB        R1,[R1,#0x0] ; Uc_byte_cnt_zb
 00000014  E1A04001  MOV         R4,R1
 00000018  E5101000  LDR         R1,=Uc_uart0_str_zb ; Uc_uart0_str_zb
 0000001C  E7C10004  STRB        R0,[R1,+R4]
  177:     if((Uc_uart0_str_zb[Uc_byte_cnt_zb] == '\r'))
 00000020  E5100000  LDR         R0,=Uc_uart0_str_zb ; Uc_uart0_str_zb
 00000024  E7D00004  LDRB        R0,[R0,+R4]
 00000028  E350000D  CMP         R0,#0x000D
 0000002C  1A00000F  BNE         L_35  ; Targ=0x70
  179:         if(Uc_byte_cnt_zb > 76)
 00000030  E354004C  CMP         R4,#0x004C
 00000034  DA000004  BLE         L_36  ; Targ=0x4C
  181:             uart0_tx_string("\n\n\r Buffer limit exceeded!!!");
 00000038  E3E00102  MVN         R0,#0x102 ; ??S_2
 0000003C  EBFFFFEF  BL          uart0_tx_string?A  ; Targ=0x0
  182:             uart0_tx_string("\n\r Please enter messege within limits(max 77 characters)");
 00000040  E3E00102  MVN         R0,#0x102 ; ??S_3
 00000044  EBFFFFED  BL          uart0_tx_string?A  ; Targ=0x0
  183:         }
 00000048  EA000005  B           L_37  ; Targ=0x64
 0000004C          L_36:
  186:               Uc_uart0_str_zb[Uc_byte_cnt_zb] = '\0';
 0000004C  E3A00000  MOV         R0,#0x0
 00000050  E5101000  LDR         R1,=Uc_uart0_str_zb ; Uc_uart0_str_zb
 00000054  E7C10004  STRB        R0,[R1,+R4]
  187:             Uc_eof_zb = 1;
 00000058  E3A01001  MOV         R1,#0x1
 0000005C  E5100000  LDR         R0,=Uc_eof_zb ; Uc_eof_zb
 00000060  E5C01000  STRB        R1,[R0,#0x0] ; Uc_eof_zb
  188:         }
 00000064          L_37:
  189:               Uc_byte_cnt_zb = 0;
 00000064  E3A01000  MOV         R1,#0x0
ARM COMPILER V2.50a,  uart                                                                 23/05/13  14:55:53  PAGE 13  

 00000068  E5100000  LDR         R0,=Uc_byte_cnt_zb ; Uc_byte_cnt_zb
 0000006C  E5C01000  STRB        R1,[R0,#0x0] ; Uc_byte_cnt_zb
  190:      }
 00000070          L_35:
  191:       if((Uc_eof_zb == 0) && (Uc_byte_cnt_zb < 77))
 00000070  E5100000  LDR         R0,=Uc_eof_zb ; Uc_eof_zb
 00000074  E5D00000  LDRB        R0,[R0,#0x0] ; Uc_eof_zb
 00000078  E3500000  CMP         R0,#0x0000
 0000007C  1A000007  BNE         L_38  ; Targ=0xA0
 00000080  E5100000  LDR         R0,=Uc_byte_cnt_zb ; Uc_byte_cnt_zb
 00000084  E5D01000  LDRB        R1,[R0,#0x0] ; Uc_byte_cnt_zb
 00000088  E1A00001  MOV         R0,R1
 0000008C  E350004D  CMP         R0,#0x004D
 00000090  AA000002  BGE         L_38  ; Targ=0xA0
  193:           Uc_byte_cnt_zb++;
 00000094  E5100000  LDR         R0,=Uc_byte_cnt_zb ; Uc_byte_cnt_zb
 00000098  E2811001  ADD         R1,R1,#0x0001
 0000009C  E5C01000  STRB        R1,[R0,#0x0] ; Uc_byte_cnt_zb
  194:       }   
 000000A0          L_38:
  195:       VICVectAddr = 0;
 000000A0  E3A01000  MOV         R1,#0x0
 000000A4  E5100000  LDR         R0,=0xFFFFF030
 000000A8  E5801000  STR         R1,[R0,#0x0]
  197: }
 000000AC  E8BD501F  LDMIA       R13!,{R0-R4,R12,LR}
 000000B0  E25EF004  SUBS        R15,R14,#0x0004
 000000B4          ENDP ; 'uart0_isr?A'


*** CODE SEGMENT '?PR?uart1_isr?A?uart':
  200: void uart1_isr(void) __irq
 00000000  E92D500F  STMDB       R13!,{R0-R3,R12,LR}
  202:     uc_u1rbr = U1RBR;
 00000004  E5100000  LDR         R0,=0xE0010000
 00000008  E5D01000  LDRB        R1,[R0,#0x0]
 0000000C  E5100000  LDR         R0,=uc_u1rbr ; uc_u1rbr
 00000010  E5C01000  STRB        R1,[R0,#0x0] ; uc_u1rbr
  212:     uart0_tx_byte(uc_u1rbr);             
 00000014  E5100000  LDR         R0,=uc_u1rbr ; uc_u1rbr
 00000018  E5D00000  LDRB        R0,[R0,#0x0] ; uc_u1rbr
 0000001C  EBFFFFF7  BL          uart0_tx_byte?A  ; Targ=0x0
  214:     switch(Uc_stat_code_gsm)
 00000020  E5100000  LDR         R0,=Uc_stat_code_gsm ; Uc_stat_code_gsm
 00000024  E5D00000  LDRB        R0,[R0,#0x0] ; Uc_stat_code_gsm
 00000028  E350000A  CMP         R0,#0x000A
 0000002C  0A00001F  BEQ         L_41  ; Targ=0xB0
 00000030  E350000B  CMP         R0,#0x000B
 00000034  0A00002D  BEQ         L_42  ; Targ=0xF0
 00000038  E3500014  CMP         R0,#0x0014
 0000003C  0A000036  BEQ         L_43  ; Targ=0x11C
 00000040  E3500015  CMP         R0,#0x0015
 00000044  0A000048  BEQ         L_44  ; Targ=0x16C
 00000048  E3500016  CMP         R0,#0x0016
 0000004C  0A000056  BEQ         L_45  ; Targ=0x1AC
 00000050  E3500017  CMP         R0,#0x0017
 00000054  0A00006C  BEQ         L_46  ; Targ=0x20C
 00000058  E3500000  CMP         R0,#0x0000
 0000005C  1A00007F  BNE         L_39  ; Targ=0x260
  216:       case  0:  if(uc_u1rbr == '\r')
 00000060          L_40:
 00000060  E5100000  LDR         R0,=uc_u1rbr ; uc_u1rbr
 00000064  E5D00000  LDRB        R0,[R0,#0x0] ; uc_u1rbr
 00000068  E1A01000  MOV         R1,R0
 0000006C  E351000D  CMP         R1,#0x000D
 00000070  1A00007A  BNE         L_39  ; Targ=0x260
  218:                       Uc_stat_code_gsm = 10;
 00000074  E3A0200A  MOV         R2,#0xA
ARM COMPILER V2.50a,  uart                                                                 23/05/13  14:55:53  PAGE 14  

 00000078  E5101000  LDR         R1,=Uc_stat_code_gsm ; Uc_stat_code_gsm
 0000007C  E5C12000  STRB        R2,[R1,#0x0] ; Uc_stat_code_gsm
  219:                       Uc_byte_cnt_gsm = 0;
 00000080  E3A02000  MOV         R2,#0x0
 00000084  E5101000  LDR         R1,=Uc_byte_cnt_gsm ; Uc_byte_cnt_gsm
 00000088  E5C12000  STRB        R2,[R1,#0x0] ; Uc_byte_cnt_gsm
  220:                     Uc_uart1_str_gsm[Uc_byte_cnt_gsm] = uc_u1rbr;   
 0000008C  E5101000  LDR         R1,=Uc_byte_cnt_gsm ; Uc_byte_cnt_gsm
 00000090  E5D11000  LDRB        R1,[R1,#0x0] ; Uc_byte_cnt_gsm
 00000094  E1A03001  MOV         R3,R1
 00000098  E5102000  LDR         R2,=Uc_uart1_str_gsm ; Uc_uart1_str_gsm
 0000009C  E7C20003  STRB        R0,[R2,+R3]
  221:                     Uc_byte_cnt_gsm++;
 000000A0  E5100000  LDR         R0,=Uc_byte_cnt_gsm ; Uc_byte_cnt_gsm
 000000A4  E2811001  ADD         R1,R1,#0x0001
 000000A8  E5C01000  STRB        R1,[R0,#0x0] ; Uc_byte_cnt_gsm
  223:                 break;
 000000AC  EA00006B  B           L_39  ; Targ=0x260
  225:       case 10:  Uc_uart1_str_gsm[Uc_byte_cnt_gsm] = uc_u1rbr;    // Status code 10 signifies that first '\r' has been 
             -received and coming bytes  7
 000000B0          L_41:
 000000B0  E5100000  LDR         R0,=uc_u1rbr ; uc_u1rbr
 000000B4  E5D00000  LDRB        R0,[R0,#0x0] ; uc_u1rbr
 000000B8  E5101000  LDR         R1,=Uc_byte_cnt_gsm ; Uc_byte_cnt_gsm
 000000BC  E5D12000  LDRB        R2,[R1,#0x0] ; Uc_byte_cnt_gsm
 000000C0  E1A03002  MOV         R3,R2
 000000C4  E5101000  LDR         R1,=Uc_uart1_str_gsm ; Uc_uart1_str_gsm
 000000C8  E7C10003  STRB        R0,[R1,+R3]
  226:                 Uc_byte_cnt_gsm++;                           // will be a part of GSM response. This response is further analyzed in case 11.
 000000CC  E5101000  LDR         R1,=Uc_byte_cnt_gsm ; Uc_byte_cnt_gsm
 000000D0  E2822001  ADD         R2,R2,#0x0001
 000000D4  E5C12000  STRB        R2,[R1,#0x0] ; Uc_byte_cnt_gsm
  227:                 if(uc_u1rbr == '\r')
 000000D8  E350000D  CMP         R0,#0x000D
 000000DC  1A00005F  BNE         L_39  ; Targ=0x260
  229:                     Uc_stat_code_gsm = 11;
 000000E0  E3A0100B  MOV         R1,#0xB
 000000E4  E5100000  LDR         R0,=Uc_stat_code_gsm ; Uc_stat_code_gsm
 000000E8  E5C01000  STRB        R1,[R0,#0x0] ; Uc_stat_code_gsm
  231:                 break;
 000000EC  EA00005B  B           L_39  ; Targ=0x260
  233:       case 11:  Uc_uart1_str_gsm[Uc_byte_cnt_gsm] = uc_u1rbr;
 000000F0          L_42:
 000000F0  E5100000  LDR         R0,=uc_u1rbr ; uc_u1rbr
 000000F4  E5D00000  LDRB        R0,[R0,#0x0] ; uc_u1rbr
 000000F8  E5101000  LDR         R1,=Uc_byte_cnt_gsm ; Uc_byte_cnt_gsm
 000000FC  E5D11000  LDRB        R1,[R1,#0x0] ; Uc_byte_cnt_gsm
 00000100  E1A02001  MOV         R2,R1
 00000104  E5101000  LDR         R1,=Uc_uart1_str_gsm ; Uc_uart1_str_gsm
 00000108  E7C10002  STRB        R0,[R1,+R2]
  234:                 Uc_uart1_str_gsm[Uc_byte_cnt_gsm + 1] = '\0';
 0000010C  E3A00000  MOV         R0,#0x0
 00000110  E5101000  LDR         R1,=Uc_uart1_str_gsm + 0x1 ; Uc_uart1_str_gsm+1
 00000114  E7C10002  STRB        R0,[R1,+R2]
  236:                 break;
 00000118  EA000050  B           L_39  ; Targ=0x260
  238:       case 20:  if(uc_u1rbr == '+')
 0000011C          L_43:
 0000011C  E5100000  LDR         R0,=uc_u1rbr ; uc_u1rbr
 00000120  E5D00000  LDRB        R0,[R0,#0x0] ; uc_u1rbr
 00000124  E1A01000  MOV         R1,R0
 00000128  E351002B  CMP         R1,#0x002B
 0000012C  1A00004B  BNE         L_39  ; Targ=0x260
  240:                     Uc_byte_cnt_gsm = 0;    
 00000130  E3A02000  MOV         R2,#0x0
 00000134  E5101000  LDR         R1,=Uc_byte_cnt_gsm ; Uc_byte_cnt_gsm
ARM COMPILER V2.50a,  uart                                                                 23/05/13  14:55:53  PAGE 15  

 00000138  E5C12000  STRB        R2,[R1,#0x0] ; Uc_byte_cnt_gsm
  241:                     SMS_cur.detail[Uc_byte_cnt_gsm] = uc_u1rbr;
 0000013C  E5101000  LDR         R1,=Uc_byte_cnt_gsm ; Uc_byte_cnt_gsm
 00000140  E5D11000  LDRB        R1,[R1,#0x0] ; Uc_byte_cnt_gsm
 00000144  E1A03001  MOV         R3,R1
 00000148  E5102000  LDR         R2,=SMS_cur ; SMS_cur
 0000014C  E7C20003  STRB        R0,[R2,+R3]
  242:                     Uc_byte_cnt_gsm++;
 00000150  E5100000  LDR         R0,=Uc_byte_cnt_gsm ; Uc_byte_cnt_gsm
 00000154  E2811001  ADD         R1,R1,#0x0001
 00000158  E5C01000  STRB        R1,[R0,#0x0] ; Uc_byte_cnt_gsm
  243:                     Uc_stat_code_gsm = 21;
 0000015C  E3A01015  MOV         R1,#0x15
 00000160  E5100000  LDR         R0,=Uc_stat_code_gsm ; Uc_stat_code_gsm
 00000164  E5C01000  STRB        R1,[R0,#0x0] ; Uc_stat_code_gsm
  245:                 break;
 00000168  EA00003C  B           L_39  ; Targ=0x260
  247:       case 21:  SMS_cur.detail[Uc_byte_cnt_gsm] = uc_u1rbr;
 0000016C          L_44:
 0000016C  E5100000  LDR         R0,=uc_u1rbr ; uc_u1rbr
 00000170  E5D00000  LDRB        R0,[R0,#0x0] ; uc_u1rbr
 00000174  E5101000  LDR         R1,=Uc_byte_cnt_gsm ; Uc_byte_cnt_gsm
 00000178  E5D12000  LDRB        R2,[R1,#0x0] ; Uc_byte_cnt_gsm
 0000017C  E1A03002  MOV         R3,R2
 00000180  E5101000  LDR         R1,=SMS_cur ; SMS_cur
 00000184  E7C10003  STRB        R0,[R1,+R3]
  248:                 Uc_byte_cnt_gsm++;                           
 00000188  E5101000  LDR         R1,=Uc_byte_cnt_gsm ; Uc_byte_cnt_gsm
 0000018C  E2822001  ADD         R2,R2,#0x0001
 00000190  E5C12000  STRB        R2,[R1,#0x0] ; Uc_byte_cnt_gsm
  249:                 if(uc_u1rbr == '\n')
 00000194  E350000A  CMP         R0,#0x000A
 00000198  1A000030  BNE         L_39  ; Targ=0x260
  251:                     Uc_stat_code_gsm = 22;
 0000019C  E3A01016  MOV         R1,#0x16
 000001A0  E5100000  LDR         R0,=Uc_stat_code_gsm ; Uc_stat_code_gsm
 000001A4  E5C01000  STRB        R1,[R0,#0x0] ; Uc_stat_code_gsm
  253:                 break;
 000001A8  EA00002C  B           L_39  ; Targ=0x260
  255:       case 22:  SMS_cur.detail[Uc_byte_cnt_gsm] = uc_u1rbr;
 000001AC          L_45:
 000001AC  E5100000  LDR         R0,=uc_u1rbr ; uc_u1rbr
 000001B0  E5D00000  LDRB        R0,[R0,#0x0] ; uc_u1rbr
 000001B4  E5101000  LDR         R1,=Uc_byte_cnt_gsm ; Uc_byte_cnt_gsm
 000001B8  E5D12000  LDRB        R2,[R1,#0x0] ; Uc_byte_cnt_gsm
 000001BC  E1A03002  MOV         R3,R2
 000001C0  E5101000  LDR         R1,=SMS_cur ; SMS_cur
 000001C4  E7C10003  STRB        R0,[R1,+R3]
  256:                 Uc_byte_cnt_gsm++;                           
 000001C8  E5101000  LDR         R1,=Uc_byte_cnt_gsm ; Uc_byte_cnt_gsm
 000001CC  E2822001  ADD         R2,R2,#0x0001
 000001D0  E5C12000  STRB        R2,[R1,#0x0] ; Uc_byte_cnt_gsm
  257:                 if(uc_u1rbr == '\n')
 000001D4  E350000A  CMP         R0,#0x000A
 000001D8  1A000020  BNE         L_39  ; Targ=0x260
  259:                     SMS_cur.detail[Uc_byte_cnt_gsm] = '\0';
 000001DC  E3A01000  MOV         R1,#0x0
 000001E0  E5100000  LDR         R0,=Uc_byte_cnt_gsm ; Uc_byte_cnt_gsm
 000001E4  E5D00000  LDRB        R0,[R0,#0x0] ; Uc_byte_cnt_gsm
 000001E8  E1A02000  MOV         R2,R0
 000001EC  E5100000  LDR         R0,=SMS_cur ; SMS_cur
 000001F0  E7C01002  STRB        R1,[R0,+R2]
  260:                     Uc_stat_code_gsm = 23;
 000001F4  E3A02017  MOV         R2,#0x17
 000001F8  E5100000  LDR         R0,=Uc_stat_code_gsm ; Uc_stat_code_gsm
 000001FC  E5C02000  STRB        R2,[R0,#0x0] ; Uc_stat_code_gsm
ARM COMPILER V2.50a,  uart                                                                 23/05/13  14:55:53  PAGE 16  

  261:                     Uc_byte_cnt_gsm = 0;
 00000200  E5100000  LDR         R0,=Uc_byte_cnt_gsm ; Uc_byte_cnt_gsm
 00000204  E5C01000  STRB        R1,[R0,#0x0] ; Uc_byte_cnt_gsm
  263:                 break;
 00000208  EA000014  B           L_39  ; Targ=0x260
  265:       case 23:  SMS_cur.data[Uc_byte_cnt_gsm] = uc_u1rbr;
 0000020C          L_46:
 0000020C  E5100000  LDR         R0,=uc_u1rbr ; uc_u1rbr
 00000210  E5D00000  LDRB        R0,[R0,#0x0] ; uc_u1rbr
 00000214  E5101000  LDR         R1,=Uc_byte_cnt_gsm ; Uc_byte_cnt_gsm
 00000218  E5D12000  LDRB        R2,[R1,#0x0] ; Uc_byte_cnt_gsm
 0000021C  E1A03002  MOV         R3,R2
 00000220  E5101000  LDR         R1,=SMS_cur + 0xC8 ; SMS_cur+200
 00000224  E7C10003  STRB        R0,[R1,+R3]
  266:                 Uc_byte_cnt_gsm++;                           
 00000228  E5101000  LDR         R1,=Uc_byte_cnt_gsm ; Uc_byte_cnt_gsm
 0000022C  E2822001  ADD         R2,R2,#0x0001
 00000230  E5C12000  STRB        R2,[R1,#0x0] ; Uc_byte_cnt_gsm
  267:                 if(uc_u1rbr == '\n')
 00000234  E350000A  CMP         R0,#0x000A
 00000238  1A000008  BNE         L_39  ; Targ=0x260
  269:                     SMS_cur.data[Uc_byte_cnt_gsm] = '\0';
 0000023C  E3A00000  MOV         R0,#0x0
 00000240  E5101000  LDR         R1,=Uc_byte_cnt_gsm ; Uc_byte_cnt_gsm
 00000244  E5D11000  LDRB        R1,[R1,#0x0] ; Uc_byte_cnt_gsm
 00000248  E1A02001  MOV         R2,R1
 0000024C  E5101000  LDR         R1,=SMS_cur + 0xC8 ; SMS_cur+200
 00000250  E7C10002  STRB        R0,[R1,+R2]
  270:                     Uc_stat_code_gsm = 24;
 00000254  E3A01018  MOV         R1,#0x18
 00000258  E5100000  LDR         R0,=Uc_stat_code_gsm ; Uc_stat_code_gsm
 0000025C  E5C01000  STRB        R1,[R0,#0x0] ; Uc_stat_code_gsm
  272:     }
 00000260          L_39:
  274:       VICVectAddr = 0;
 00000260  E3A01000  MOV         R1,#0x0
 00000264  E5100000  LDR         R0,=0xFFFFF030
 00000268  E5801000  STR         R1,[R0,#0x0]
  276: }
 0000026C  E8BD500F  LDMIA       R13!,{R0-R3,R12,LR}
 00000270  E25EF004  SUBS        R15,R14,#0x0004
 00000274          ENDP ; 'uart1_isr?A'



Module Information          Static
----------------------------------
  code size            =    ------
  data size            =       308
  const size           =       111
End of Module Information.


ARM COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
